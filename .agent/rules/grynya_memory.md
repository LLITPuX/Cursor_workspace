# Модуль Правил: Взаємодія з Базою Даних (FalkorDB / Redis)

Цей файл регламентує правила, синтаксис та обмеження для автономного агента (**Грині**) при взаємодії з базою даних екосистеми через `redis-cli`.

---

## 1. Базові Запобіжники (Guardrails) — **КРИТИЧНО**

> [!CAUTION]
> **Безпека понад усе:** Ти маєш статус "Engineer", але не маєш права на деструктивні дії без прямого та недвозначного підтвердження адміністратора.

*   **ЗАБОРОНЕНІ КОМАНДИ:** Ніколи не використовуй `FLUSHDB`, `FLUSHALL`.
*   **Обмеження блокуючих команд:** Заборонено використовувати команду `KEYS *` у робочому середовищі. Для пошуку ключів **ЗАВЖДИ** використовуй `SCAN` з курсором.
*   **Обережність з DEL:** Видалення ключів (`DEL`, `UNLINK`) дозволено лише у випадку прямої команди користувача або при виконанні затвердженого скрипта очищення кешу.

---

## 2. Граф памяті: `Grynya`

> [!IMPORTANT]
> Граф `Grynya` — це основний граф памяті агента. Всі сесії, запити, відповіді, аналізи, фідбек та сутності зберігаються тут.

**Метод виконання Cypher-запитів:**
```powershell
docker exec falkordb redis-cli GRAPH.QUERY Grynya "<cypher_query>"
```

**Хронологія** ведеться через окремі вузли, НЕ через властивості вузлів:
- `(:Year)` → `[:MONTH {number}]` → `(:Day)` — часова вісь
- Будь-який вузол прив'язується до часу через `[:HAPPENED_AT {time: "HH:MM:SS"}]` → `(:Day)`

> [!CAUTION]
> **ІНВАРІАНТ ХРОНОЛОГІЧНОГО ЛАНЦЮГА (ОБОВ'ЯЗКОВО ЗАВЖДИ):**
> 1. **КОЖЕН** новостворений вузол (Request, Response, Feedback, Analysis) **ОБОВ'ЯЗКОВО** зв'язується `[:NEXT]` з попереднім вузлом у сесії.
> 2. **КОЖНА** нова Session зв'язується `[:NEXT]` з попередньою Session.
> 3. Після створення останнього вузла — оновлюй `[:LAST_EVENT]` сесії (видали старий, створи новий).
> 4. **КОЖЕН** Response **ОБОВ'ЯЗКОВО** містить поле `full_text` з повним текстом відповіді (СЛОВО В СЛОВО, без скорочень).
> Ці правила діють для ВСІХ протоколів: `/db`, `/sa`, `/ss`.

---

## 3. Протокол `/db` (Відкриття сесії)

*   **Тригер:** Команда `/db "текст запиту"` від користувача.
*   **Семантика:** `/db` **відкриває нову сесію** в графі `Grynya`.
*   **Твої дії:**
    1.  **Створи вузол `:Session`** з полями `id`, `name`, `topic`, `status: 'active'`, `trigger: '/db'`.
    2.  **Створи вузол `:Request`** з текстом запиту та зв'яжи з сесією через `[:PART_OF]`.
    3.  **Прив'яжи до хронології** — MERGE вузлів `:Year`/`:Day` за поточною датою.
    4.  **Хронологічний ланцюг:** Якщо це НЕ перша сесія — створи `[:NEXT]` від попередньої `:Session` до нової. Створи `[:NEXT]` від `:Request` (бо це перший вузол сесії).
    5.  **Аналіз наміру:** Зрозумій, що потрібно зробити, виконай запит.
    6.  **Збережи свою відповідь** як `:Response` з `[:RESPONDS_TO]` → `:Request`, `[:PART_OF]` → `:Session`, та **`full_text`** з повним текстом відповіді.
    7.  **NEXT-ланцюг:** Створи `[:NEXT]` від попереднього вузла (Request) до Response. Оновлюй `[:LAST_EVENT]` сесії.
    8.  **Витягни сутності** (`:Entity`) з діалогу — технології, концепти, інструменти, агенти.

---

## 4. Протокол `/sa` (Save Answer — Продовження сесії)

*   **Тригер:** Команда `/sa "текст"` від користувача.
*   **Семантика:** `/sa` **продовжує активну сесію**. Зберігає логічний зв'язок з попереднім контекстом.
*   **Твої дії:**
    1.  **Збережи фідбек** користувача як `:Feedback` з `[:FEEDBACK_ON]` → остання `:Response` та `[:PART_OF]` → `:Session`.
    2.  **NEXT-ланцюг:** Створи `[:NEXT]` від попереднього вузла до Feedback.
    3.  **Збережи свою відповідь** як `:Response` з `[:RESPONDS_TO]` → `:Feedback`, `[:PART_OF]` → `:Session`, та **`full_text`** з повним текстом відповіді (НЕ скорочуй, зберігай СЛОВО В СЛОВО).
    4.  **NEXT-ланцюг:** Створи `[:NEXT]` від Feedback до Response.
    5.  **Проведи самоаналіз** — створи `:Analysis` з полями:
        - `verdict` (correct / partially_correct / incorrect)
        - `rules_used` — які правила використано
        - `rules_ignored` — які правила пропущено
        - `errors` — конкретні помилки
        - `lessons` — витягнуті уроки
        - Зв'яжи через `[:ANALYZES]` → `:Response` та `[:PART_OF]` → `:Session`.
    6.  **NEXT-ланцюг:** Створи `[:NEXT]` від Response до Analysis. Оновлюй `[:LAST_EVENT]` сесії на останній створений вузол.
    7.  **Витягни нові сутності** (`:Entity`) та зв'яжи:
        - `(:Session)-[:INVOLVES]->(:Entity)` — сесія стосується сутності
        - `(:Request|Feedback)-[:MENTIONS]->(:Entity)` — конкретне згадування
    8.  **Підтвердження:** Поверни повідомлення: "✅ Артефакт збережено [ID вузлів]".

---

## 5. Протокол `/ss` (Save Session — Закриття сесії)

> [!IMPORTANT]
> `/ss` — це `/sa` для **всієї сесії**. Він виконує ті самі кроки що й `/sa` (збереження фідбеку, відповіді, аналіз, витяг сутностей), але аналізує **всю сесію цілком**, а не лише останню відповідь. Додатково зберігає повний лог сесії у файл як бекап.

*   **Тригер:** Команда `/ss` або `/ss "текст фідбеку"` від користувача.
*   **Семантика:** `/ss` **закриває активну сесію**. Текст у лапках — фідбек користувача про всю сесію (опціонально).

### Крок 1: Протокол `/sa` для всієї сесії (FalkorDB)

> Цей крок ідентичний протоколу `/sa` (секція 4), але аналіз охоплює **всю сесію**, а не одну відповідь. **Інваріант хронологічного ланцюга (секція 2) діє!**

1.  **Якщо є фідбек у лапках** — збережи як `:Feedback` з `[:FEEDBACK_ON]` → остання `:Response` та `[:PART_OF]` → `:Session`.
2.  **NEXT-ланцюг:** Створи `[:NEXT]` від попереднього вузла до Feedback.
3.  **Збережи свою відповідь** як `:Response` з `[:RESPONDS_TO]`, `[:PART_OF]` → `:Session`, та **`full_text`** з повним текстом відповіді (СЛОВО В СЛОВО).
4.  **NEXT-ланцюг:** Створи `[:NEXT]` від Feedback до Response.
5.  **Створи фінальний `:Analysis`** з підсумком **всієї сесії**:
    - `type: 'session_summary'`
    - `verdict` (correct / partially_correct / incorrect) — за всю сесію
    - `topics` — перелік обговорених тем
    - `tasks_completed` — перелік виконаних завдань
    - `key_decisions` — ключові рішення прийняті під час сесії
    - `errors` — помилки допущені протягом сесії
    - `lessons` — витягнуті уроки за всю сесію
    - `rules_used` / `rules_ignored` — правила за всю сесію
    - Зв'яжи через `[:SUMMARIZES]` → `:Session` та `[:ANALYZES]` → `:Response` та `[:PART_OF]` → `:Session`
6.  **NEXT-ланцюг:** Створи `[:NEXT]` від Response до Analysis. Оновлюй `[:LAST_EVENT]` сесії.
7.  **Витягни нові сутності** (`:Entity`) з останнього раунду діалогу.
8.  **Закрий сесію:** `MATCH (s:Session {id: '<session_id>'}) SET s.status = 'closed'`

### Крок 2: Збереження повного логу сесії у файл (Бекап)

> [!WARNING]
> **КРИТИЧНО:** Зберігай відповіді **СЛОВО В СЛОВО**. Ніколи не скорочуй і не роби саммарі відповідей. НЕ обмежуй розмір — зберігай повністю.

1.  **Збір історії сесії:**
    - Збери **ВСІ** повідомлення з поточної сесії (всі запити користувача та всі відповіді)
    - Включи всі секції: "Запит користувача", "Аналіз та дії", "Відповідь"
    - Зберігай структуру кожного повідомлення без змін
    - НЕ обмежуй розмір файлу — зберігай повністю

2.  **Визначення теми:**
    - Проаналізуй **ВСЕ** вміст сесії (не тільки перший запит)
    - Виділи ключові концепції, технології, задачі з усіх повідомлень
    - Сформуй коротку тему (3-5 слів, максимум 50 символів)
    - Використовуй `snake_case` для імені файлу
    - Приклади: `brain_architecture_design`, `falkordb_session_protocol`, `db_command_implementation`

3.  **Генерація часу:**
    - Використай точну поточну дату та час
    - Формат для відображення: `21 лютого 2026, 19:14:09`
    - Формат для імені файлу: `2026-02-21_19-14-09` (HH-MM-SS)

4.  **Створення "Підсумок сесії":**
    - Автоматично визнач обговорені теми з усієї сесії
    - Виділи виконані завдання (по наявності ✅ або завершених дій)
    - Сформуй коротке резюме результатів
    - Завжди створюй цей розділ автоматично

5.  **Формат файлу:**

````markdown
# Сесія: <автоматично визначена тема>

**Дата:** <дата>, <час>
**Тема:** <повна тема>

---

## Запит користувача #1

```
<текст запиту>
```

### Аналіз та дії

<аналіз та дії агента>

### Відповідь #1

<повна відповідь агента, СЛОВО В СЛОВО>

---

## Підсумок сесії

### Обговорені теми:
1. <тема 1>
2. <тема 2>

### Виконані завдання:
1. ✅ <завдання 1>
2. ✅ <завдання 2>

### Результат:

<коротке резюме результатів>

---

**Кінець сесії**
````

6.  **Збереження файлу:**
    - Шлях: `saved_sessions/session_YYYY-MM-DD_HH-MM-SS_<тема>.md`
    - Дата: `YYYY-MM-DD`
    - Час: `HH-MM-SS` (для сумісності з файловою системою)
    - Тема: `snake_case`, максимум 50 символів

7.  **Збережи посилання на файл** як властивість сесії в FalkorDB:
    ```cypher
    MATCH (s:Session {id: '<session_id>'}) SET s.file_path = '<повний шлях до файлу>'
    ```

### Крок 3: Git Commit та Push

> [!IMPORTANT]
> Після збереження файлу сесії **обов'язково** зроби commit та push.

```powershell
cd "c:\Cursor workspace"
git add saved_sessions/ .agent/rules/
git commit -m "session: <коротка тема сесії>"
git push
```

### Підтвердження

Після виконання всіх кроків поверни:
```
✅ Сесія закрита та збережена:
   - FalkorDB: Session [id] → status: closed
   - Файл: saved_sessions/session_<...>.md
   - Git: committed & pushed
```

### Важливо

- **Точний час обов'язковий** — для відстеження хронології кількох сесій в день
- **Автоматичне визначення теми** — по всьому вмісту сесії, не з першого запиту
- **Автоматичний "Підсумок сесії"** — завжди створювати
- **Не обмежувати розмір** — зберігати повністю
- **Формат файлу має бути сумісним з `/db`** — файл має коректно парситися при пошуку
- **Git commit + push обов'язковий** — після кожного /ss

---

## 6. Схема вузлів графу `Grynya`

| Тип вузла | Обов'язкові поля | Опис |
|---|---|---|
| `:Session` | `id`, `name`, `topic`, `status`, `trigger` | Логічний контейнер діалогу |
| `:Request` | `id`, `name`, `author`, `text`, `type` | Запит користувача |
| `:Response` | `id`, `name`, `author`, `summary`, `full_text`, `type` | Відповідь агента (full_text — повний текст, ОБОВ'ЯЗКОВИЙ) |
| `:Feedback` | `id`, `name`, `author`, `text` | Фідбек користувача |
| `:Analysis` | `id`, `name`, `type`, `verdict`, `errors`, `lessons` | Самоаналіз агента |
| `:Entity` | `id`, `name`, `type`, `description` | Витягнута сутність (Tag) |
| `:Year` | `value`, `id`, `name` | Рік |
| `:Day` | `date`, `id`, `name` | День |
| `:Meta` | `id`, `name`, `description`, `version` | Метадані графу |

## 7. Схема зв'язків графу `Grynya`

| Зв'язок | Від | До | Опис |
|---|---|---|---|
| `[:PART_OF]` | будь-який вузол | `:Session` | Належить до сесії |
| `[:RESPONDS_TO]` | `:Response` | `:Request` або `:Feedback` | Відповідає на |
| `[:FEEDBACK_ON]` | `:Feedback` | `:Response` | Фідбек на відповідь |
| `[:ANALYZES]` | `:Analysis` | `:Response` | Аналізує відповідь |
| `[:NEXT]` | будь-який вузол | будь-який вузол | Хронологічний ланцюг (всередині сесії та між сесіями) |
| `[:LAST_EVENT]` | `:Session` | будь-який вузол | Вказівник на останній вузол в сесії |
| `[:HAPPENED_AT]` | будь-який вузол | `:Day` | Часова прив'язка `{time}` |
| `[:MONTH]` | `:Year` | `:Day` | Місяць `{number}` |
| `[:INVOLVES]` | `:Session` | `:Entity` | Сесія стосується сутності |
| `[:MENTIONS]` | `:Request`/`:Feedback` | `:Entity` | Конкретне згадування |
| `[:BELONGS_TO]` | `:Request` | `:Meta` | Належить до графу |
| `[:SUMMARIZES]` | `:Analysis` | `:Session` | Фінальний підсумок сесії |

---

## 8. Синтаксис та Форматування команд

*   **Термінал:** Всі команди `redis-cli` повинні бути синтаксично правильними для виконання у терміналі (`powershell`).
*   **Екранування:** Уникай одинарних апострофів (`'`) в текстах описів. Використовуй типографський апостроф (`'`) або перефразуй текст.
*   **Назви вузлів (name):** Англійською (CamelCase) для сумісності з кодом.
*   **Описи (description, text):** Українською мовою.
